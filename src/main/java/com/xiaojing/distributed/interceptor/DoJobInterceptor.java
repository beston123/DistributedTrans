package com.xiaojing.distributed.interceptor;import com.google.inject.Inject;import com.google.inject.Singleton;import com.xiaojing.distributed.dao.UndoJobDao;import com.xiaojing.distributed.model.UndoJob;import com.xiaojing.distributed.util.Context;import org.aopalliance.intercept.MethodInterceptor;import org.aopalliance.intercept.MethodInvocation;import org.slf4j.Logger;import org.slf4j.LoggerFactory;@Singletonpublic class DoJobInterceptor implements MethodInterceptor {    private static final Logger LOGGER = LoggerFactory.getLogger(DoJobInterceptor.class);    @Inject    private UndoJobDao undoJobDao;    @Override    public Object invoke(MethodInvocation methodInvocation) throws Throwable {        Context context = (Context) methodInvocation.getArguments()[0];        //clear current undo log at do action start        context.getPendingUndoJobs().clear();        Object result;        try {            result = invokeDoJobMethod(methodInvocation);            saveUndoLogToDB(context);            commitTransaction(context);        } catch (Throwable throwable) {            try {                context.getConnection().rollback();                context.getConnection().close();            } catch (Throwable innerThrowable) {                LOGGER.warn("Exception in rollback:", innerThrowable);            }            throw throwable;        }finally {            if(null != context.getConnection())            context.getConnection().close();        }        return result;    }    /**     * 执行DoJob的实质性操作     *     * 副作用1为将根据userId分库得到connection，并将其存储在context中，UndoLogDao共享此connection，两者处于同一个事务中     * connection的autoCommit属性根据分库的@Shared中的autoCommit属性来设置，事务的开始在@Shared对应的SharedKeyInterceptor     *     * 副作用2为执行DoJob的操作时，传入的undoJob为null，此时UndoJobInterceptor并不执行Undo操作     * 而是将此次DoJob对应的UndoJob存储在Context的PendingUndoJobs中     *     * @param methodInvocation     * @return     * @throws Throwable 出Exception时，rollback并close此connection     */    private Object invokeDoJobMethod(MethodInvocation methodInvocation)throws Throwable{        LOGGER.debug("====Invocation DoJob======");        return methodInvocation.proceed();    }    /**     * 从context中拿到invokeMethod副作用中保存的undoJob，并将其保存在数据库中     * @param context     * @throws Exception 出Exception时，rollback并close此connection     */    private void saveUndoLogToDB(Context context)throws Exception{        LOGGER.debug("====Save UndoJob DB======");        for (UndoJob undoJob : context.getPendingUndoJobs()) {            undoJobDao.insertUndo(context.getConnection(), undoJob);        }    }    /**     * 从context中拿到invokeMethod副作用中保存的undoJob，并将其保存在数据库中     * @param context     */    private void saveUndoLogToMem(Context context){        LOGGER.debug("====Save UndoJob MEM======");        context.getDistributeJob().getUndoJobList().addAll(context.getPendingUndoJobs());    }    /**     * 当DoJob和保存UndoLog都成功时，提交事务     * @param context     * @throws Exception 出Exception时，rollback并close此connection     */    private void commitTransaction(Context context)throws Exception{        context.getConnection().commit();        //todo 当commit超时时，并不直接rollback，由离线程序进行处理        saveUndoLogToMem(context);        context.getConnection().close();        context.setConnection(null);    }}